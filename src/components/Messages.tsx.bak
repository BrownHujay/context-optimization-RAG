// src/components/Messages.tsx
import { useEffect, useRef, useState } from "react";
import { useMessages, useChat as useStreamingChat } from "../hooks";
import type { Message as ApiMessage } from "../api/types";
import { useAuth } from "../context/AuthContext";
import { useChat } from "../context/ChatContext";
import { AnimatePresence, motion } from "framer-motion";
import { useNavigate } from "react-router-dom";

// Local Message interface for component display
interface DisplayMessage {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: string;
}

export default function Messages() {
  const { currentUser } = useAuth();
  const { activeChat } = useChat();
  const accountId = currentUser?.id || '';
  const chatId = activeChat?.id || '';
  
  // CRITICAL FIX: Add direct DOM manipulation to force streaming text to appear
  // This bypasses React's render cycle for maximum performance and reliability
  const streamingTextRef = useRef<HTMLPreElement>(null);
  
  // Get the streaming state from useChat hook and pass the ref
  const { streamingResponse, isStreaming } = useStreamingChat(accountId, chatId, streamingTextRef);
  
  // REAL-TIME STREAMING: Listen for streaming events and update DOM INSTANTLY
  // Track the last streaming response for debugging and force renders
  const [lastStreamUpdate, setLastStreamUpdate] = useState<string>("");
  // Add force render counter to ensure component updates
  const [forceRenderCounter, setForceRenderCounter] = useState(0);
  
  // Use forceRenderCounter in render to ensure React picks up state changes
  useEffect(() => {
    // Only update DOM when streaming is active
    if (isStreaming && lastStreamUpdate && typeof window !== 'undefined' && (window as any).updateAnyStreamingText) {
      (window as any).updateAnyStreamingText(lastStreamUpdate);
    }
  }, [forceRenderCounter, lastStreamUpdate, isStreaming]);
  
  // Create stable ref for event handlers that won't change on re-renders
  const stableHandlerRef = useRef<{text: string}>({ text: "" });
  
  // CRITICAL FIX: Setup global handler on mount to guarantee capture of all events
  useEffect(() => {
    // Create a global function that can update any streaming text element
    if (typeof window !== 'undefined') {
      // Global function to update streaming text that will work regardless of component state
      (window as any).updateAnyStreamingText = (text: string) => {
        // Store the text in a stable ref that persists across renders
        stableHandlerRef.current.text = text;
        
        // Update all possible streaming text elements by ID
        const possibleIds = ['streaming-text-display', 'http-chat-streaming-content', 'chat-input-streaming-content'];
        let updated = false;
        
        possibleIds.forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.textContent = text;
            updated = true;
          }
        });
        
        // Also update our React state to force a render
        setLastStreamUpdate(text);
        setForceRenderCounter(prev => prev + 1);
        
        return updated;
      };
    }
    
    // Register global event listener that's independent of component lifecycle
    const globalStreamHandler = (e: any) => {
      if (e?.detail?.text) {
        const text = e.detail.text;
        (window as any).updateAnyStreamingText(text);
      }
    };
    
    // Add listener to window - will persist even if component re-renders
    window.addEventListener('streaming-chunk', globalStreamHandler, true);
    window.addEventListener('chat-stream-update', globalStreamHandler, true);
    
    return () => {
      window.removeEventListener('streaming-chunk', globalStreamHandler, true);
      window.removeEventListener('chat-stream-update', globalStreamHandler, true);
    };
  }, []);
  
  // Get messages data from the hook - must be before we use these variables
  const { messages: apiMessages, loading, error, refreshMessages } = useMessages(accountId, chatId);
  const [displayMessages, setDisplayMessages] = useState<DisplayMessage[]>([]);
  
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const messagesEndRef = useRef<HTMLDivElement | null>(null);
  
  // Function to scroll to bottom of messages
  const scrollToBottom = () => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  };
  
  // Force refresh handler - used to ensure database sync
  const handleForceRefresh = async () => {
    try {
      if (activeChat?.id) {
        console.log('Force refreshing chat messages for chat:', activeChat.id);
        await refreshMessages();
        
        // Immediate scroll to ensure smooth UX
        scrollToBottom();
        
        // Secondary scroll with delay as fallback
        setTimeout(() => {
          scrollToBottom();
        }, 50); // Minimal delay for render to complete
      }
    } catch (error) {
      console.error('Error refreshing messages:', error);
    }
  };
  
  // Listen for streaming chunks and update the streaming text element
  useEffect(() => {
    // First, define a handler that we can use both in the component and globally
    const handleStreamingChunk = (e: CustomEvent) => {
      try {
        if (e?.detail?.text) {
          const text = e.detail.text;
          // Update our local state for React
          setLastStreamUpdate(text);
          
          // Directly update the DOM for instant feedback
          if (streamingTextRef.current) {
            streamingTextRef.current.textContent = text;
          }
        }
      } catch (err) {
        console.error('Error handling streaming chunk:', err);
      }
    };
        
    // Add event listener with capture phase to ensure it runs first
    window.addEventListener('streaming-chunk', handleStreamingChunk as unknown as EventListener, true);
    
    // Also add in bubble phase as a backup
    window.addEventListener('streaming-chunk', handleStreamingChunk as unknown as EventListener);
    
    // Add listener for forced refresh when database sync happens
    window.addEventListener('force-messages-refresh', handleForceRefresh as unknown as EventListener);
    
    // Add listener for the new optimized database refresh events
    window.addEventListener('database-messages-updated', handleForceRefresh as unknown as EventListener);
    window.addEventListener('refresh-messages-now', handleForceRefresh as unknown as EventListener);
    
    // Clean up
    return () => {
      window.removeEventListener('streaming-chunk', handleStreamingChunk as unknown as EventListener, true);
      window.removeEventListener('streaming-chunk', handleStreamingChunk as unknown as EventListener);
      window.removeEventListener('force-messages-refresh', handleForceRefresh as unknown as EventListener);
      window.removeEventListener('database-messages-updated', handleForceRefresh as unknown as EventListener);
      window.removeEventListener('refresh-messages-now', handleForceRefresh as unknown as EventListener);
    };
  }, [activeChat?.id]);
  
  // Also update from React state changes as a fallback
  useEffect(() => {
    if (streamingTextRef.current && streamingResponse) {
      streamingTextRef.current.textContent = streamingResponse;
      console.log(`üîÑ React state update: ${streamingResponse.length} chars`);
    }
  }, [streamingResponse]);
  
  // For navigation
  const navigate = useNavigate();
  
  // Debug log when active chat changes
  useEffect(() => {
    console.log(`üîç Active chat changed: ${activeChat?.id} - ${activeChat?.title}`);
    
    // CRITICAL FIX: Only navigate if we're not already on this URL
    // This prevents the page from reloading during streaming
    if (activeChat?.id) {
      const currentPath = window.location.pathname;
      const targetPath = `/chat/${activeChat.id}`;
      
      // Only navigate if we're not already on this path
      if (currentPath !== targetPath) {
        console.log(`üö© Navigating from ${currentPath} to ${targetPath}`);
        navigate(targetPath, { replace: true }); // Use replace to avoid adding to history
      } else {
        console.log(`üö´ Skipping navigation - already at ${currentPath}`);
      }
    }
  }, [activeChat, navigate]);
  
  // Convert API messages to display format
  useEffect(() => {
    if (!apiMessages) {
      console.log('üö´ No apiMessages available');
      return;
    }
    
    console.log('üìä Processing API messages:', apiMessages.length, 'messages');
    
    // Map API messages to display format
    const formattedMessages = apiMessages.map((msg: ApiMessage): DisplayMessage => {
      // CRITICAL FIX: Properly determine content based on role
      // For user messages, content is in the 'text' field
      // For assistant messages, content is in the 'response' field
      let content = '';
      if (msg.role === 'user') {
        content = msg.text || '';
        console.log(`üë§ Processing user message: ${content.substring(0, 30)}...`);
      } else {
        content = msg.response || '';
        console.log(`ü§ñ Processing assistant message: ${content.substring(0, 30)}...`);
      }
      
      // Format timestamp safely
      let formattedTimestamp = 'Unknown time';
      try {
        if (msg.created_at) {
          formattedTimestamp = new Date(msg.created_at).toLocaleTimeString();
        }
      } catch (err) {
        console.error('Error formatting timestamp:', err);
      }
      
      // Log for debugging message content
      console.log(`Message ${msg.id} (${msg.role}): ${content.substring(0, 30)}...`);
      
      // Cast the role to the required type for TypeScript
      const safeRole: 'user' | 'assistant' = msg.role === 'user' ? 'user' : 'assistant';
      
      return {
        id: msg.id,
        role: safeRole,
        content: content,
        timestamp: formattedTimestamp
      };
    });
    
    setDisplayMessages(formattedMessages);

  // Debug log message count
  console.log(`üìä Mapped ${formattedMessages.length} messages to display format`);
}, [apiMessages, chatId]);

// Using scrollToBottom function defined earlier 
    // Always use bottom-up loading for optimal UX
    if (!isStreaming && displayMessages.length > 0) {
      // Only scroll to bottom if not streaming and we have messages
      scrollToBottom();
      
      // Mark the current scroll position for future reference
      const currentScrollY = window.scrollY;
      const currentScrollHeight = document.body.scrollHeight;
      
      // Store these values temporarily to help with scrolling optimization
      sessionStorage.setItem('scrollPosition', currentScrollY.toString());
      sessionStorage.setItem('scrollHeight', currentScrollHeight.toString());
    } else if (isStreaming) {
      // During streaming, continuously scroll to bottom to show new content
      scrollToBottom();
    }
  }, [displayMessages, isStreaming, streamingResponse]);
  
  // Optimize bottom-up loading and ensure smooth scrolling
  useEffect(() => {
    // When streaming ends, force an immediate refresh of messages
    // This creates a smooth transition from streaming to static content
    if (!isStreaming && lastStreamUpdate) {
      // Small delay to let the UI stabilize first
      const timer = setTimeout(() => {
        handleForceRefresh();
      }, 50);
      
      return () => clearTimeout(timer);
    }
  }, [isStreaming, lastStreamUpdate]);

  // ... (rest of the code remains the same)
  // Handle loading and error states
  if (loading && displayMessages.length === 0) {
    return (
      <div className="flex-1 flex items-center justify-center bg-[var(--bg-primary)]">
        <div className="animate-pulse text-[var(--text-secondary)]">
          Loading messages...
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex-1 flex items-center justify-center bg-[var(--bg-primary)]">
        <div className="text-red-500">
          Error loading messages: {error}
        </div>
      </div>
    );
  }

  if (!activeChat) {
    console.log('‚ö†Ô∏è No active chat selected, rendering empty state');
    return (
      <div className="flex-1 flex items-center justify-center bg-[var(--bg-primary)]">
        <div className="text-[var(--text-secondary)] text-center">
          <p className="text-xl mb-2">No active chat selected</p>
          <p className="text-sm">Select a chat from the sidebar or create a new one</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full w-full bg-[var(--bg-primary)]">
      <div
        ref={scrollContainerRef}
        className="w-full px-4 py-4 space-y-4"
      >
        <AnimatePresence>
          {displayMessages.map((message) => (
            <motion.div
              key={message.id}
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
              className={message.role === "user" 
                ? "px-4 py-2 rounded-xl text-left break-words break-all whitespace-pre-wrap text-white ml-auto" 
                : "px-4 py-2 rounded-lg text-left break-words break-all whitespace-pre-wrap mr-auto text-[var(--text-primary)]"}
              style={{
                maxWidth: "66%",
                width: message.content.length < 35 ? "fit-content" : "100%",
                minWidth: "4rem",
                backgroundColor: message.role === "user" ? "var(--theme-color)" : "var(--chat-bubble)",
                border: "none",
                outline: "none",
                boxShadow: "none"
              }}
            >
              <p>{message.content}</p>
              <div className="text-xs opacity-70 text-right mt-1">
                {message.timestamp}
              </div>
            </motion.div>
          ))}
          
          {/* ASSISTANT MESSAGE CLONE: Using 100% identical styling as normal assistant messages */}
          {isStreaming && (
            <motion.div
              key="streaming-response-static-key"
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0 }}
              transition={{ duration: 0.3 }}
              className="px-4 py-2 rounded-lg text-left break-words break-all whitespace-pre-wrap mr-auto text-[var(--text-primary)]"
              style={{
                maxWidth: "66%",
                width: "100%", 
                minWidth: "4rem",
                backgroundColor: "var(--chat-bubble)",
                border: "none",
                outline: "none",
                boxShadow: "none"
              }}
            >
              {/* TRIPLE REDUNDANT APPROACH: */}
              {/* 1. Direct DOM Reference */}
              <pre 
                ref={streamingTextRef}
                className="whitespace-pre-wrap font-sans"
                id="streaming-text-display"
                data-is-streaming={isStreaming.toString()}
              >
                {/* 2. React State from useStreamingChat */}
                {streamingResponse || lastStreamUpdate || "AI is thinking..."}
              </pre>

              {/* 3. Manual DOM Update via Script Tag */}
              <script
                dangerouslySetInnerHTML={{
                  __html: `
                    // Streamlined script with better cleanup
                    (function() {
                      // Store interval ID in window object for cleanup
                      if (window.streamingCheckInterval) {
                        clearInterval(window.streamingCheckInterval);
                        window.streamingCheckInterval = null;
                      }
                      
                      window.updateStreamingDisplay = function(text) {
                        const el = document.getElementById('streaming-text-display');
                        if (el) {
                          el.textContent = text || el.textContent || "Processing...";
                        }
                      };
                      
                      // Check streaming status attribute to know when to stop checking
                      window.streamingCheckInterval = setInterval(() => {
                        const el = document.getElementById('streaming-text-display');
                        if (!el || el.getAttribute('data-is-streaming') === 'false') {
                          // Clean up when streaming ends or element is gone
                          clearInterval(window.streamingCheckInterval);
                          window.streamingCheckInterval = null;
                        } else if (el && (!el.textContent || el.textContent === "AI is thinking...")) {
                          window.dispatchEvent(new CustomEvent('check-streaming'));
                        }
                      }, 500); // Even less frequent checks
                      
                      // Also clean up interval when page unloads
                      window.addEventListener('unload', function() {
                        if (window.streamingCheckInterval) {
                          clearInterval(window.streamingCheckInterval);
                          window.streamingCheckInterval = null;
                        }
                      });
                    })();
                  `
                }}
              />
            
              <div className="text-xs opacity-70 text-right mt-1">
                <span className="inline-block animate-pulse">‚óè</span> Typing...
              </div>
            </motion.div>
          )}
        </AnimatePresence>
        <div ref={messagesEndRef} className="h-4" />
      </div>
    </div>
  );
}
